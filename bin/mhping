#!/usr/bin/perl -T

use 5.008008;
use utf8;
use warnings FATAL => 'all';
use threads;
use threads::shared;
use Thread::Queue;
use Getopt::Long;
use Scalar::Util qw(looks_like_number);
use Time::HiRes qw(sleep);

BEGIN {
    $ENV{PATH} = '/bin:/usr/bin';
}

$|++;

my $VERSION = 0.003;

my %option;
Getopt::Long::Configure('bundling');
GetOptions(
    'f|filename=s' => \$option{filename},
    'i|interval=s' => \$option{interval},
    'h|help'       => sub { show_help(); exit 3; },
    'v|version'    => sub { show_version(); exit 0; },
) or do { show_help(); exit 3; };

if ( defined $option{interval} ) {
    check_interval( $option{interval} ) or exit 3;
}

my @hosts = parse_hosts( $option{filename} );

exit 3 unless @hosts;

my @workers;
foreach my $host (@hosts) {
    my $status_queue  = Thread::Queue->new;
    my $message_queue = Thread::Queue->new;
    my $worker        = threads->create(
        'ping_host',
        $status_queue,
        $message_queue,
        $host,
        $option{interval}
    );
    push(
        @workers, {
            thread        => $worker,
            status_queue  => $status_queue,
            message_queue => $message_queue,
            host          => $host,
        }
    );
}
threads->create( 'show_report', \@workers, $option{interval} )->join;

exit 0;

sub show_help {
    print <<HELP;
Usage: mhping [options] [systems...]
  -f,--filename file    read list of targets from a file
  -i,--interval n       interval between sending ping packets (default: 1s)
  -v,--version          show version
HELP

    return;
}

sub show_version {
    print <<VERSION;
mhping : Version $VERSION
VERSION

    return;
}

sub check_interval {
    my $interval = shift;
    if ( looks_like_number($interval) ) {
        return 1;
    }
    else {
        print "mhping: Bad timing interval!\n";
        return;
    }
}

sub parse_hosts {
    my $hosts_file = shift;

    return @ARGV if scalar @ARGV;

    my $hosts_fh;
    if ( not defined $hosts_file ) {
        if ( -t STDIN ) {
            print "mhping: Write one host per line. ";
            print "End with CTRL-d or an empty line.\n";
        }
        $hosts_fh = 'STDIN';
    }
    elsif ( $hosts_file eq '-' ) {
        $hosts_fh = 'STDIN';
    }
    else {
        open( $hosts_fh, '<', $hosts_file )
          or die "mhping: Can't open file hosts file '$hosts_file'!\n";
    }
    my @hosts;
    while (<$hosts_fh>) {
        chomp;
        if (/^\s*$/) {
            last;
        }
        elsif (/^[a-z0-9\.]+$/i) {
            push( @hosts, $_ );
        }
        else {
            print "mhping: Bad host format $_\n";
            return;
        }
    }

    return @hosts;
}

sub show_report {
    my $workers = shift;
    my $interval = shift || 1;

    my $tty_clear = qx( clear );

    my $display_count = 0;
    while (1) {
        my @report_lines;
        my $worker_count;
        foreach my $worker ( @{$workers} ) {
            my $host = $worker->{host};
            my $status
              = $worker->{status_queue}->pending
              ? $worker->{status_queue}->dequeue
              : 'BLOCK';
            my $message
              = $worker->{message_queue}->pending
              ? $worker->{message_queue}->dequeue
              : '';

            $worker_count++;

            if ( $worker->{thread}->is_running ) {
                $message = '-' if $status eq 'BLOCK' and $display_count >= 2;

                my $line_format
                  = looks_like_number($message)
                  ? "%2d. %-30s %10.1f\n"
                  : "%2d. %-30s %10s\n";

                push(
                    @report_lines,
                    sprintf( $line_format, $worker_count, $host, $message )
                );
            }
            elsif ( $status eq 'BAD_HOST' ) {
                terminate_all_threads();
                print "mhping: Unknown host $host\n";
                exit 3;
            }
        }

        $display_count++;

        print $tty_clear;
        printf " %4s %39s\n", 'Host', 'Last';
        print '-' x 45, "\n";
        print foreach @report_lines;

        sleep $interval;
    }

    return;
}

sub ping_host {
    my $status_queue  = shift;
    my $message_queue = shift;
    my $host          = shift;
    my $interval      = shift || 1;

    local $SIG{TERM} = sub { threads->exit };

    $host     = ( $host     =~ /^([a-z0-9\.]+)$/i ) ? $1 : return;
    $interval = ( $interval =~ /^([0-9\.]+)$/ )     ? $1 : return;

    open( my $ping, '-|', "ping -i $interval $host 2>&1" );
    while (<$ping>) {
        my $status;
        my $message;
        if (m/time=(.+)\sms$/) {
            $status  = 'ECHO_REPLY';
            $message = $1;
        }
        elsif (m/unknown\shost/) {
            $status = 'BAD_HOST';
        }
        else {
            $status  = 'UNKNOWN';
            $message = '???';
        }
        $status_queue->enqueue($status);
        $message_queue->enqueue($message);
    }

    return;
}

sub terminate_all_threads {
    foreach my $thread ( threads->list ) {
        if ( $thread->is_running ) {
            $thread->kill('SIGTERM')->detach;
        }
        else {
            $thread->join;
        }
    }

    return;
}

# vim: set ts=4 sw=4 et:
