#!/usr/bin/env perl

use 5.008008;
use utf8;
use warnings FATAL => 'all';
use threads;
use threads::shared;
use Thread::Queue;
use Getopt::Long;
use Scalar::Util qw(looks_like_number);
use Time::HiRes qw(sleep);

$|++;

my $VERSION = 0.003;

my %option;
Getopt::Long::Configure('bundling');
GetOptions(
    'f|filename=s' => \$option{filename},
    'i|interval=s' => \$option{interval},
    'h|help'       => sub { show_help(); exit 3; },
    'v|version'    => sub { show_version(); exit 0; },
) or do { show_help(); exit 3; };

if ( defined $option{interval} ) {
    check_interval( $option{interval} ) or exit 3;
}

my @hosts = parse_hosts( $option{filename} );

my @workers;
foreach my $host (@hosts) {
    my $queue = Thread::Queue->new;
    my $worker
      = threads->create( 'ping_host', $queue, $host, $option{interval} );
    push( @workers, { thread => $worker, queue => $queue, host => $host } );
}
threads->create( 'show_report', \@workers, $option{interval} )->join;

exit 0;

sub show_help {
    print <<HELP;
Usage: mhping [options] [systems...]
  -f,--filename file    read list of targets from a file
  -i,--interval n       interval between sending ping packets (default: 1s)
  -v,--version          show version
HELP

    return;
}

sub show_version {
    print <<VERSION;
mhping : Version $VERSION
VERSION

    return;
}

sub check_interval {
    my $interval = shift;
    if ( looks_like_number($interval) ) {
        return 1;
    }
    else {
        print "mhping: Bad timing interval!\n";
        return;
    }
}

sub parse_hosts {
    my $hosts_file = shift;

    return @ARGV if scalar @ARGV;

    my $hosts_fh;
    if ( not defined $hosts_file ) {
        if (-t STDIN) {
            print "mhping: Write one host per line and end with CTRL-D.\n"
        }
        $hosts_fh = 'STDIN';
    }
    elsif ( $hosts_file eq '-' ) {
        $hosts_fh = 'STDIN';
    }
    else {
        open( my $hosts_fh, '<', $hosts_file )
          or die "mhping: Can't open file hosts file '$hosts_file'!\n";
    }
    my @hosts;
    while (<$hosts_fh>) {
        chomp;
        push( @hosts, $_ );
    }

    return @hosts;
}

sub show_report {
    my $workers = shift;
    my $interval = shift || 1;

    my $tty_clear = qx( clear );

    while (1) {
        my @stats;
        my $worker_count;
        foreach my $worker ( @{$workers} ) {
            my $host  = $worker->{host};
            my $queue = $worker->{queue}->dequeue;

            $worker_count++;

            if ( $worker->{thread}->is_running ) {
                next unless $queue->{message};

                push(
                    @stats,
                    sprintf(
                        "%2d %-30s %10s \n",
                        $worker_count, $host, $queue->{message},
                    )
                );
            }
            elsif ( $queue->{status} eq 'BAD_HOST' ) {
                terminate_all_threads();
                print "mhping: Unknown host $host\n";
                exit 3;
            }
        }

        print $tty_clear;
        printf "%2s %-30s %10s \n", '#', 'Host', 'RTT';
        print '-' x 46, "\n";
        print foreach @stats;

        sleep $interval;
    }

    return;
}

sub ping_host {
    my $job_queue = shift;
    my $host      = shift;
    my $interval  = shift || 1;

    local $SIG{TERM} = sub { threads->exit };

    open( my $ping, '-|', "ping -i $interval $host 2>&1" );
    while (<$ping>) {
        my $status;
        my $message;
        if (m/time=(.+)$/) {
            $status  = 'ECHO_REPLY';
            $message = $1;
        }
        elsif (m/unknown\shost/) {
            $status = 'BAD_HOST';
        }
        else {
            $status  = 'UNKNOWN';
            $message = '?';
        }
        $job_queue->enqueue( { status => $status, message => $message } );
    }

    return;
}

sub terminate_all_threads {
    foreach my $thread ( threads->list ) {
        if ( $thread->is_running ) {
            $thread->kill('SIGTERM')->detach;
        }
        else {
            $thread->join;
        }
    }

    return;
}

# vim: set ts=4 sw=4 et:
